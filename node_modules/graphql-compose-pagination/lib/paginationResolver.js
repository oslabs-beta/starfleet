"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preparePaginationResolver = preparePaginationResolver;
exports.DEFAULT_PER_PAGE = exports.DEFAULT_RESOLVER_NAME = void 0;

var _preparePaginationType = require("./preparePaginationType");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DEFAULT_RESOLVER_NAME = 'pagination';
exports.DEFAULT_RESOLVER_NAME = DEFAULT_RESOLVER_NAME;
const DEFAULT_PER_PAGE = 20;
exports.DEFAULT_PER_PAGE = DEFAULT_PER_PAGE;

function preparePaginationResolver(tc, opts) {
  if (!tc || tc.constructor.name !== 'ObjectTypeComposer') {
    throw new Error('First arg for prepareConnectionResolver() should be instance of ObjectTypeComposer');
  }

  const resolverName = opts.paginationResolverName || DEFAULT_RESOLVER_NAME;

  if (!opts.countResolverName) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.countResolverName`.');
  }

  const countResolver = tc.getResolver(opts.countResolverName);

  if (!countResolver) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.countResolverName}' ` + 'due opts.countResolverName.');
  }

  const countResolve = countResolver.getResolve();

  if (!opts.findResolverName) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.findResolverName`.');
  }

  const findManyResolver = tc.getResolver(opts.findResolverName);

  if (!findManyResolver) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.findResolverName}' ` + 'due opts.countResolverName.');
  }

  const findManyResolve = findManyResolver.getResolve();
  const additionalArgs = {};

  if (findManyResolver.hasArg('filter')) {
    const filter = findManyResolver.getArg('filter');

    if (filter) {
      additionalArgs.filter = filter;
    }
  }

  if (findManyResolver.hasArg('sort')) {
    const sort = findManyResolver.getArg('sort');

    if (sort) {
      additionalArgs.sort = sort;
    }
  }

  return tc.schemaComposer.createResolver({
    type: (0, _preparePaginationType.preparePaginationTC)(tc),
    name: resolverName,
    kind: 'query',
    args: _objectSpread({
      page: {
        type: 'Int',
        description: 'Page number for displaying'
      },
      perPage: {
        type: 'Int',
        description: '',
        defaultValue: opts.perPage || DEFAULT_PER_PAGE
      }
    }, additionalArgs),
    resolve: async rp => {
      let countPromise;
      let findManyPromise;
      const {
        projection = {},
        args,
        rawQuery
      } = rp;
      const page = parseInt(args.page, 10) || 1;

      if (page <= 0) {
        throw new Error('Argument `page` should be positive number.');
      }

      const perPage = parseInt(args.perPage, 10) || opts.perPage || DEFAULT_PER_PAGE;

      if (perPage <= 0) {
        throw new Error('Argument `perPage` should be positive number.');
      }

      const countParams = _objectSpread({}, rp, {
        rawQuery,
        args: _objectSpread({}, rp.args, {
          filter: _objectSpread({}, rp.args.filter)
        })
      });

      if (projection.count || projection.pageInfo && (projection.pageInfo.itemCount || projection.pageInfo.pageCount)) {
        countPromise = countResolve(countParams);
      } else {
        countPromise = Promise.resolve(0);
      }

      const findManyParams = _objectSpread({}, rp);

      if (projection && projection.items) {
        // combine top level projection
        // (maybe somebody add additional fields via rp.projection)
        // and items (record needed fields)
        findManyParams.projection = _objectSpread({}, projection, projection.items);
      } else {
        findManyParams.projection = _objectSpread({}, projection);
      }

      const limit = perPage;
      const skip = (page - 1) * perPage;
      findManyParams.args.limit = limit + 1; // +1 document, to check next page presence

      if (skip > 0) {
        findManyParams.args.skip = skip;
      } // pass findMany ResolveParams to top resolver


      rp.findManyResolveParams = findManyParams;
      rp.countResolveParams = countParams; // This allows to optimize and not actually call the findMany resolver
      // if only the count is projected

      if ((projection.count || projection.pageInfo) && Object.keys(projection).length === 1) {
        findManyPromise = Promise.resolve([]);
      } else {
        findManyPromise = findManyResolve(findManyParams);
      }

      return Promise.all([findManyPromise, countPromise]).then(([items, count]) => {
        const result = {
          count,
          items: items.length > limit ? items.slice(0, limit) : items,
          pageInfo: {
            currentPage: page,
            perPage,
            itemCount: count,
            pageCount: Math.ceil(count / perPage),
            hasPreviousPage: page > 1,
            hasNextPage: items.length > limit || page * perPage < count
          }
        };
        return result;
      });
    }
  });
}