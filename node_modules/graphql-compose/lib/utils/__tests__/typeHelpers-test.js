"use strict";

var _typeHelpers = require("../typeHelpers");

var _graphql = require("../../graphql");

var _ = require("../..");

describe('typeHelpers', () => {
  describe('getComposeTypeName()', () => {
    it('understand strings', () => {
      expect((0, _typeHelpers.getComposeTypeName)('MyTypeName')).toBe('MyTypeName');
      expect((0, _typeHelpers.getComposeTypeName)('type AAA { f: Int }')).toBe('AAA');
    });
    it('understands GraphQL named types', () => {
      expect((0, _typeHelpers.getComposeTypeName)(new _graphql.GraphQLObjectType({
        name: 'OutputType',
        fields: () => ({})
      }))).toBe('OutputType');
      expect((0, _typeHelpers.getComposeTypeName)(new _graphql.GraphQLInputObjectType({
        name: 'InputType',
        fields: () => ({})
      }))).toBe('InputType');
    });
    it('understands compose types', () => {
      expect((0, _typeHelpers.getComposeTypeName)(_.schemaComposer.createObjectTC('TypeTC'))).toBe('TypeTC');
      expect((0, _typeHelpers.getComposeTypeName)(_.schemaComposer.createInputTC('TypeITC'))).toBe('TypeITC');
    });
  });
  it('check SDL types', () => {
    const output = 'type Out { name: String! }';
    const input = 'input Filter { minAge: Int }';
    const enumType = 'enum Sort { ASC DESC }';
    const scalar = 'scalar UInt';
    const iface = 'interface User { name: String }';
    const union = 'union U = A | B';
    expect((0, _typeHelpers.isTypeDefinitionString)(output)).toBeTruthy();
    expect((0, _typeHelpers.isOutputTypeDefinitionString)(output)).toBeTruthy();
    expect((0, _typeHelpers.isOutputTypeDefinitionString)(input)).toBeFalsy();
    expect((0, _typeHelpers.isTypeDefinitionString)(input)).toBeTruthy();
    expect((0, _typeHelpers.isInputTypeDefinitionString)(input)).toBeTruthy();
    expect((0, _typeHelpers.isInputTypeDefinitionString)(output)).toBeFalsy();
    expect((0, _typeHelpers.isTypeDefinitionString)(enumType)).toBeTruthy();
    expect((0, _typeHelpers.isEnumTypeDefinitionString)(enumType)).toBeTruthy();
    expect((0, _typeHelpers.isEnumTypeDefinitionString)(output)).toBeFalsy();
    expect((0, _typeHelpers.isTypeDefinitionString)(scalar)).toBeTruthy();
    expect((0, _typeHelpers.isScalarTypeDefinitionString)(scalar)).toBeTruthy();
    expect((0, _typeHelpers.isScalarTypeDefinitionString)(output)).toBeFalsy();
    expect((0, _typeHelpers.isTypeDefinitionString)(iface)).toBeTruthy();
    expect((0, _typeHelpers.isInterfaceTypeDefinitionString)(iface)).toBeTruthy();
    expect((0, _typeHelpers.isInterfaceTypeDefinitionString)(output)).toBeFalsy();
    expect((0, _typeHelpers.isTypeDefinitionString)(union)).toBeTruthy();
    expect((0, _typeHelpers.isUnionTypeDefinitionString)(union)).toBeTruthy();
    expect((0, _typeHelpers.isUnionTypeDefinitionString)(output)).toBeFalsy();
  });
  it('check type name', () => {
    expect((0, _typeHelpers.isTypeNameString)('aaaa')).toBeTruthy();
    expect((0, _typeHelpers.isTypeNameString)('Aaaaa')).toBeTruthy();
    expect((0, _typeHelpers.isTypeNameString)('A_')).toBeTruthy();
    expect((0, _typeHelpers.isTypeNameString)('_A')).toBeTruthy();
    expect((0, _typeHelpers.isTypeNameString)('A_123')).toBeTruthy();
    expect((0, _typeHelpers.isTypeNameString)('123')).toBeFalsy();
    expect((0, _typeHelpers.isTypeNameString)('A-')).toBeFalsy();
  });
});