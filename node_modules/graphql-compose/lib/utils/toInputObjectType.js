"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toInputObjectType = toInputObjectType;
exports.convertInputObjectField = convertInputObjectField;

var _ObjectTypeComposer = require("../ObjectTypeComposer");

var _NonNullComposer = require("../NonNullComposer");

var _ListComposer = require("../ListComposer");

var _ThunkComposer = require("../ThunkComposer");

var _InterfaceTypeComposer = require("../InterfaceTypeComposer");

var _typeHelpers = require("./typeHelpers");

var _misc = require("./misc");

var _UnionTypeComposer = require("../UnionTypeComposer");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function toInputObjectType(tc, opts = {}) {
  if (tc.hasInputTypeComposer()) {
    return tc.getInputTypeComposer();
  }

  const prefix = opts.prefix || '';
  const postfix = opts.postfix || 'Input';
  const inputTypeName = `${prefix}${tc.getTypeName()}${postfix}`;
  const inputTypeComposer = tc.schemaComposer.createInputTC(inputTypeName);
  tc.setInputTypeComposer(inputTypeComposer);
  const fieldNames = tc.getFieldNames();
  fieldNames.forEach(fieldName => {
    const fieldOpts = _objectSpread({}, opts, {
      fieldName,
      outputTypeName: tc.getTypeName()
    });

    const fc = tc.getField(fieldName);
    const fieldInputType = convertInputObjectField(fc.type, fieldOpts, tc.schemaComposer);

    if (fieldInputType) {
      inputTypeComposer.setField(fieldName, {
        type: fieldInputType,
        description: fc.description
      });
    }
  });
  return inputTypeComposer;
}

function convertInputObjectField(field, opts, schemaComposer) {
  let tc = field;
  const wrappers = [];

  while (tc instanceof _ListComposer.ListComposer || tc instanceof _NonNullComposer.NonNullComposer || tc instanceof _ThunkComposer.ThunkComposer) {
    if (tc instanceof _ThunkComposer.ThunkComposer) {
      tc = tc.getUnwrappedTC();
    } else {
      wrappers.unshift(tc.constructor);
      tc = tc.ofType;
    }
  }

  if (tc instanceof _UnionTypeComposer.UnionTypeComposer) {
    return null;
  }

  if (!(0, _typeHelpers.isSomeInputTypeComposer)(tc)) {
    if (tc instanceof _ObjectTypeComposer.ObjectTypeComposer || tc instanceof _InterfaceTypeComposer.InterfaceTypeComposer) {
      const typeOpts = {
        prefix: opts.prefix || '',
        postfix: opts.postfix || 'Input'
      };
      tc = toInputObjectType(tc, typeOpts);
    } else {
      // eslint-disable-next-line
      console.error(`graphql-compose: can not convert field '${opts.outputTypeName || ''}.${opts.fieldName || ''}' to InputType` + '\nIt should be ObjectType or InterfaceType, but got \n' + (0, _misc.inspect)(tc));
      tc = schemaComposer.get('JSON');
    }
  }

  if (tc) {
    // wrap TypeComposer back
    tc = wrappers.reduce((type, Wrapper) => new Wrapper(type), tc);
  }

  return tc;
}